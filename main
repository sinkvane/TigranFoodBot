// bot.js
import TelegramBot from "node-telegram-bot-api";
import cron from "node-cron";
import { config } from "./config.js";
import { POINTS, REMINDERS } from "./reports.js";

// ==== Логгер ====
function log(message) {
  const now = new Date().toISOString();
  console.log(`[${now}] ${message}`);
}

// ==== Конфигурация ====
const { TOKEN, ADMIN_CHAT_ID, TIMEZONE } = config;

// ==== Состояние пользователей ====
const userState = {}; 
// { userId: { step, point, verified, lastReminder, pendingReminders, reminderTimer } }

// ==== Создание бота ====
const bot = new TelegramBot(TOKEN, { polling: true });
log("Бот запущен и ожидает команду /start");

// ==== Функции для клавиатур ====
function getStartKeyboard() {
  return { reply_markup: { keyboard: [[{ text: "/start" }]], resize_keyboard: true, one_time_keyboard: false } };
}

function getEndKeyboard() {
  return { reply_markup: { keyboard: [[{ text: "/end" }]], resize_keyboard: true, one_time_keyboard: false } };
}

// ==== Команда /start ====
bot.onText(/\/start/, (msg) => {
  const chatId = msg.chat.id;

  const state = userState[chatId];
  if (state && state.verified) {
    bot.sendMessage(chatId, "Смена уже активна. Для завершения нажмите /end.", getEndKeyboard());
    return;
  }

  bot.sendMessage(chatId, "Нажмите /start, чтобы начать смену.", getStartKeyboard());

  // Inline-кнопки с точками
  const inlineButtons = Object.keys(POINTS).map(key => [{ text: key, callback_data: `point:${key}` }]);
  bot.sendMessage(chatId, "Выберите точку:", { reply_markup: { inline_keyboard: inlineButtons } });

  log(`Пользователь ${chatId} вызвал /start`);
});

// ==== Команда /end ====
bot.onText(/\/end/, (msg) => {
  const chatId = msg.chat.id;
  const state = userState[chatId];

  if (!state || !state.verified) {
    bot.sendMessage(chatId, "Смена не активна. Нажмите /start, чтобы начать смену.", getStartKeyboard());
    return;
  }

  // Очистка таймеров и pending
  if (state.reminderTimer) {
    clearTimeout(state.reminderTimer);
    state.reminderTimer = null;
  }
  state.pendingReminders = [];
  state.verified = false;
  state.step = null;
  state.lastReminder = null;

  bot.sendMessage(chatId, "✅ Смена завершена. Нажмите /start для новой смены.", getStartKeyboard());
  log(`Пользователь ${chatId} завершил смену с помощью /end`);
});

// ==== Обработка callback_query ====
bot.on("callback_query", (query) => {
  const chatId = query.message.chat.id;
  const data = query.data;

  if (data.startsWith("point:")) {
    const pointName = data.split(":")[1];
    if (!POINTS[pointName]) return;

    userState[chatId] = { step: "enter_password", point: pointName, verified: false, pendingReminders: [], reminderTimer: null };
    bot.sendMessage(chatId, `Введите пароль для ${pointName}:`);
    log(`Пользователь ${chatId} выбрал точку "${pointName}" через inline button`);
    bot.answerCallbackQuery(query.id);
    return;
  }

  if (data.startsWith("report:")) {
    const key = data.split(":")[1];
    const reminder = REMINDERS.find(r => r.key === key);
    if (!reminder || !userState[chatId]) {
      bot.answerCallbackQuery(query.id);
      return;
    }

    const state = userState[chatId];
    state.lastReminder = reminder.name;
    state.pendingReminders = state.pendingReminders.filter(r => r !== reminder.name);

    bot.sendMessage(chatId, `Вы выбрали отчет: "${reminder.name}". Отправьте фото или текст.`);
    bot.answerCallbackQuery(query.id);
    log(`Пользователь ${chatId} выбрал отчет "${reminder.name}"`);
    return;
  }
});

// ==== Обработка сообщений (пароль и отчеты) ====
bot.on("message", (msg) => {
  const chatId = msg.chat.id;
  const text = msg.text;

  if (!userState[chatId]) return;
  const state = userState[chatId];

  // --- Проверка пароля ---
  if (state.step === "enter_password") {
    if (text === POINTS[state.point].password) {
      state.verified = true;
      state.step = "reports";

      bot.sendMessage(chatId, "Пароль верный! Теперь вы будете получать напоминания об отчетах.", getEndKeyboard());
      log(`Пользователь ${chatId} авторизован для точки "${state.point}"`);

      scheduleReminders(chatId, state.point);
    } else {
      bot.sendMessage(chatId, "Неверный пароль, попробуйте еще раз:");
      log(`Неверный пароль для точки "${state.point}" пользователем ${chatId}`);
    }
    return;
  }

  // --- Отправка отчета ---
  if (state.verified && (msg.text || msg.photo)) {
    if (!state.lastReminder) return;

    const reminderName = state.lastReminder;
    const reportText = msg.text || msg.caption || "";
    const senderLink = `[${msg.from.username ? '@'+msg.from.username : msg.from.first_name}](tg://user?id=${msg.from.id})`;
    const forwardText = `📌 Отчет "${reminderName}" с точки ${state.point}\nОтправил: ${senderLink}\n${reportText}`;

    const sendReport = msg.photo
      ? bot.sendPhoto(ADMIN_CHAT_ID, msg.photo[msg.photo.length - 1].file_id, { caption: forwardText, parse_mode: "Markdown" })
      : bot.sendMessage(ADMIN_CHAT_ID, forwardText, { parse_mode: "Markdown" });

    sendReport.then(() => {
      // Подтверждение пользователю
      bot.sendMessage(chatId, "✅ Отчет отправлен, благодарим!");
      log(`Отчет "${reminderName}" от ${msg.from.id} отправлен`);

      state.lastReminder = null;

      // Теперь показываем оставшиеся отчеты, если есть
      if (state.pendingReminders.length > 0) {
        setTimeout(() => sendPendingReports(chatId), 200);
      }
    }).catch(err => {
      console.error("Ошибка при отправке отчета админу:", err);
      bot.sendMessage(chatId, "❌ Произошла ошибка при отправке отчета, попробуйте снова.");
    });
  }
});

// ==== Функция отправки оставшихся отчетов ====
function sendPendingReports(chatId) {
  const state = userState[chatId];
  if (!state || !state.pendingReminders || state.pendingReminders.length === 0) return;

  const buttons = state.pendingReminders.map(r => {
    const rem = REMINDERS.find(rem => rem.name === r);
    if (!rem) return null;
    return [{ text: r, callback_data: `report:${rem.key}` }];
  }).filter(Boolean);

  if (buttons.length > 0) {
    bot.sendMessage(chatId, "🔔 Поступили оставшиеся отчеты, выберите один для отправки:", { reply_markup: { inline_keyboard: buttons } });
    log(`Оставшиеся отчеты отправлены пользователю ${chatId}: ${state.pendingReminders.join(", ")}`);
  }
}

// ==== Планирование cron-напоминаний ====
function scheduleReminders(chatId, pointName) {
  const tzKey = POINTS[pointName].tz;
  const tz = TIMEZONE[tzKey];

  REMINDERS.forEach(({ name, cron: cronExp }) => {
    cron.schedule(
      cronExp,
      () => {
        const state = userState[chatId];
        if (!state || !state.verified) return;

        if (!state.pendingReminders) state.pendingReminders = [];
        if (!state.pendingReminders.includes(name)) state.pendingReminders.push(name);

        if (!state.reminderTimer) {
          state.reminderTimer = setTimeout(() => {
            sendPendingReports(chatId);
            if (state) {
              state.pendingReminders = [];
              state.reminderTimer = null;
            }
          }, 1000);
        }
      },
      { timezone: tz }
    );
  });
}
